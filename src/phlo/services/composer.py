"""
Compose Generator Module

Generates docker-compose.yml and .env files from service definitions.
"""

import logging
import os
import shutil
from pathlib import Path
from typing import Any

import yaml

from phlo.services.discovery import ServiceDefinition, ServiceDiscovery

logger = logging.getLogger(__name__)


class ComposeGenerator:
    """Generates docker-compose.yml from service definitions."""

    def __init__(self, discovery: ServiceDiscovery):
        """Initialize with a service discovery instance."""
        self.discovery = discovery

    def generate_compose(
        self,
        services: list[ServiceDefinition],
        output_dir: Path,
        dev_mode: bool = False,
        phlo_src_path: str | None = None,
    ) -> str:
        """Generate docker-compose.yml content.

        Args:
            services: List of services to include.
            output_dir: Target directory (for resolving relative paths).
            dev_mode: If True, add phlo source mounts for dev services.
            phlo_src_path: Path to phlo source (relative to project root).

        Returns:
            Docker compose YAML content as string.
        """
        # Sort services by dependencies
        sorted_services = self.discovery.resolve_dependencies(services)

        compose: dict[str, Any] = {"services": {}}

        for service in sorted_services:
            compose["services"][service.name] = self._build_service_config(
                service, output_dir, dev_mode=dev_mode, phlo_src_path=phlo_src_path
            )

        # Add header comment with dev mode flag for stale detection
        dev_mode_str = "true" if dev_mode else "false"
        header = f"""# Phlo Infrastructure Stack
# Generated by: phlo services init
# Dev mode: {dev_mode_str}
# Modify .env to customize configuration

"""
        return header + yaml.dump(compose, default_flow_style=False, sort_keys=False)

    def _build_service_config(
        self,
        service: ServiceDefinition,
        output_dir: Path,
        dev_mode: bool = False,
        phlo_src_path: str | None = None,
    ) -> dict[str, Any]:
        """Build docker-compose service configuration."""
        config: dict[str, Any] = {}

        # Image or build
        if service.image:
            config["image"] = service.image
        elif service.build:
            # Determine build context
            context = service.build.get("context", ".")
            if context == "source" and service.source_path:
                # Use the service's source directory as build context
                context = str(service.source_path)
            if isinstance(context, str):
                context_path = Path(context)
                if context_path.is_absolute():
                    context = os.path.relpath(context_path, output_dir)
            build_config: dict[str, Any] = {"context": context}
            if service.build.get("dockerfile"):
                build_config["dockerfile"] = service.build["dockerfile"]
            if service.build.get("args"):
                build_config["args"] = service.build["args"]
            config["build"] = build_config

        # Profile (if not default)
        if service.profile:
            config["profiles"] = [service.profile]

        # Compose configuration
        compose = service.compose

        if compose.get("restart"):
            config["restart"] = compose["restart"]
        else:
            config["restart"] = "unless-stopped"

        if compose.get("container_name"):
            config["container_name"] = compose["container_name"]

        if compose.get("environment"):
            config["environment"] = compose["environment"]

        if compose.get("ports"):
            config["ports"] = compose["ports"]

        if compose.get("volumes"):
            config["volumes"] = list(compose["volumes"])  # Copy to avoid mutation
        else:
            config["volumes"] = []

        # Dev mode: inject phlo source mount and project directory for dependency sync
        if dev_mode and service.phlo_dev and phlo_src_path:
            # Mount phlo source code (for live code changes)
            phlo_mount = f"{phlo_src_path}:/usr/local/lib/python3.11/site-packages/phlo:ro"
            config["volumes"].append(phlo_mount)
            # Mount entire phlo project directory for dependency sync with uv pip install -e .
            # phlo_src_path points to src/phlo, so ../.. is the project root
            project_mount = f"{phlo_src_path}/../..:/opt/phlo-dev:rw"
            config["volumes"].append(project_mount)
            # Add environment variable to enable dev mode sync
            if "environment" not in config:
                config["environment"] = {}
            if isinstance(config["environment"], dict):
                config["environment"]["PHLO_DEV_MODE"] = "true"
            elif isinstance(config["environment"], list):
                config["environment"].append("PHLO_DEV_MODE=true")

        # Remove empty volumes list
        if not config["volumes"]:
            del config["volumes"]

        # Add env_file for phlo_dev services to pick up project secrets (e.g., GITHUB_TOKEN)
        # Path is relative to .phlo/ directory where docker-compose.yml lives
        if service.phlo_dev:
            config["env_file"] = ["../.env"]

        if compose.get("command"):
            config["command"] = compose["command"]

        if compose.get("entrypoint"):
            config["entrypoint"] = compose["entrypoint"]

        if compose.get("healthcheck"):
            config["healthcheck"] = compose["healthcheck"]

        # Dependencies
        if service.depends_on:
            depends_config: dict[str, dict[str, str]] = {}
            for dep in service.depends_on:
                dep_service = self.discovery.get_service(dep)
                if dep_service:
                    # Check if dependency has healthcheck
                    if dep_service.compose.get("healthcheck"):
                        depends_config[dep] = {"condition": "service_healthy"}
                    elif dep == "minio-setup":
                        depends_config[dep] = {"condition": "service_completed_successfully"}
                    else:
                        depends_config[dep] = {"condition": "service_started"}
            if depends_config:
                config["depends_on"] = depends_config

        return config

    def generate_env(self, services: list[ServiceDefinition]) -> str:
        """Generate .env file content.

        Args:
            services: List of services to include.

        Returns:
            Environment file content as string.
        """
        lines = [
            "# Phlo Infrastructure Configuration",
            "# Generated by: phlo services init",
            "",
        ]

        # Group env vars by category
        categories: dict[str, list[tuple[str, dict[str, Any]]]] = {}

        for service in services:
            category = service.category
            if category not in categories:
                categories[category] = []

            for var_name, var_config in service.env_vars.items():
                categories[category].append((var_name, var_config))

        # Write grouped env vars
        category_titles = {
            "core": "Core Infrastructure",
            "orchestration": "Orchestration",
            "bi": "Business Intelligence",
            "admin": "Admin Tools",
            "api": "API Layer",
            "observability": "Observability",
        }

        for category, vars_list in categories.items():
            if not vars_list:
                continue

            title = category_titles.get(category, category.title())
            lines.append(f"# {title}")

            for var_name, var_config in vars_list:
                default = var_config.get("default", "")
                description = var_config.get("description", "")

                if description:
                    lines.append(f"# {description}")

                lines.append(f"{var_name}={default}")

            lines.append("")

        return "\n".join(lines)

    def copy_service_files(
        self,
        services: list[ServiceDefinition],
        output_dir: Path,
    ) -> list[str]:
        """Copy additional files required by services.

        Args:
            services: List of services.
            output_dir: Target .phlo directory.

        Returns:
            List of copied file paths.
        """
        copied: list[str] = []

        for service in services:
            if not service.files or not service.source_path:
                continue

            for file_spec in service.files:
                source = service.source_path / file_spec["source"]
                dest = output_dir / file_spec["dest"]

                if not source.exists():
                    logger.warning("Source file not found: %s", source)
                    continue

                # Create parent directories
                dest.parent.mkdir(parents=True, exist_ok=True)

                # Copy file or directory
                if source.is_dir():
                    if dest.exists():
                        shutil.rmtree(dest)
                    shutil.copytree(source, dest)
                else:
                    shutil.copy2(source, dest)

                copied.append(str(dest.relative_to(output_dir)))

        return copied

    def generate_gitignore(self) -> str:
        """Generate .gitignore content for .phlo directory."""
        return """# Phlo infrastructure files
.env
volumes/

# Dagster runtime data
dagster/storage/
dagster/history/
dagster/schedules/
dagster/logs/
"""
